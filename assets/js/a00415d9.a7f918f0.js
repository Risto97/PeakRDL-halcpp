"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[171],{5680:(e,n,t)=>{t.d(n,{xA:()=>s,yg:()=>m});var i=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=i.createContext({}),d=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},s=function(e){var n=d(e.components);return i.createElement(p.Provider,{value:n},e.children)},g="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},y=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),g=d(t),y=a,m=g["".concat(p,".").concat(y)]||g[y]||c[y]||r;return t?i.createElement(m,o(o({ref:n},s),{},{components:t})):i.createElement(m,o({ref:n},s))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=y;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[g]="string"==typeof e?e:a,o[1]=l;for(var d=2;d<r;d++)o[d]=t[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}y.displayName="MDXCreateElement"},9835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var i=t(8168),a=(t(6540),t(5680));const r={sidebar_position:3},o="RegNode",l={unversionedId:"hierarchy/nodes/reg/reg",id:"hierarchy/nodes/reg/reg",title:"RegNode",description:"RegNode is a template class that represents a reg component in SystemRDL.",source:"@site/docs/hierarchy/nodes/reg/reg.md",sourceDirName:"hierarchy/nodes/reg",slug:"/hierarchy/nodes/reg/",permalink:"/PeakRDL-halcpp/docs/hierarchy/nodes/reg/",draft:!1,editUrl:"https://github.com/risto97/peakrdl-halcpp/tree/master/docs/hierarchy/nodes/reg/reg.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"documentationSidebar",previous:{title:"FieldNode",permalink:"/PeakRDL-halcpp/docs/hierarchy/nodes/field/"},next:{title:"AddrmapNode",permalink:"/PeakRDL-halcpp/docs/hierarchy/nodes/addrmap/"}},p={},d=[{value:"<code>RegBase</code>",id:"regbase",level:2},{value:"<code>RegRdMixin</code> and <code>RegWrMixin</code>",id:"regrdmixin-and-regwrmixin",level:2},{value:"Register access methods",id:"register-access-methods",level:3},{value:"<code>RegNode</code>",id:"regnode-1",level:2},{value:"<code>RegRO</code>",id:"regro",level:3},{value:"<code>FieldWO</code>",id:"fieldwo",level:3},{value:"<code>FieldRW</code>",id:"fieldrw",level:3}],s={toc:d},g="wrapper";function c(e){let{components:n,...t}=e;return(0,a.yg)(g,(0,i.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"regnode"},"RegNode"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"RegNode")," is a template class that represents a ",(0,a.yg)("inlineCode",{parentName:"p"},"reg")," component in SystemRDL.",(0,a.yg)("br",null),"\n",(0,a.yg)("inlineCode",{parentName:"p"},"RegNode")," can contain only ",(0,a.yg)("inlineCode",{parentName:"p"},"FieldNodes"),", and it must be instantiated within ",(0,a.yg)("inlineCode",{parentName:"p"},"AddrmapNode")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"RegFileNode"),"."),(0,a.yg)("h2",{id:"regbase"},(0,a.yg)("inlineCode",{parentName:"h2"},"RegBase")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"RegBase")," is a base class providing ",(0,a.yg)("inlineCode",{parentName:"p"},"constexpr")," constants for basic information about the register.\nThe base class does not provide any ",(0,a.yg)("inlineCode",{parentName:"p"},"write")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"read")," capabilities."),(0,a.yg)("p",null,"It is a template that takes the following template arguments"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <uint32_t BASE, uint32_t WIDTH, typename PARENT_TYPE>\nclass RegBase {\n")),(0,a.yg)("p",null,"The template parameters are:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"BASE")," is an address offset within an ",(0,a.yg)("inlineCode",{parentName:"li"},"AddrmapNode"),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"WIDTH")," is a width of the register."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"PARENT_TYPE")," accepts a specialization of an ",(0,a.yg)("inlineCode",{parentName:"li"},"AddrmapNode")," template, and is the type of the containing addrmap.\nIt is necessary to pass this type, because the ",(0,a.yg)("inlineCode",{parentName:"li"},"write")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"read")," methods of the field will pass these requests to the parent register, along with the value written.")),(0,a.yg)("h2",{id:"regrdmixin-and-regwrmixin"},(0,a.yg)("inlineCode",{parentName:"h2"},"RegRdMixin")," and ",(0,a.yg)("inlineCode",{parentName:"h2"},"RegWrMixin")),(0,a.yg)("p",null,"Since the ",(0,a.yg)("inlineCode",{parentName:"p"},"RegBase")," class does not provide any ",(0,a.yg)("inlineCode",{parentName:"p"},"write")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"read")," capabilities, these two ",(0,a.yg)("inlineCode",{parentName:"p"},"Mixins")," are supposed to provide the additional capabilities to the registers.\nThey are supposed to provide ",(0,a.yg)("inlineCode",{parentName:"p"},"setters")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"getters")," for the registers, along with operator overloads.\nThe memory access is not done by these mixins, but the requests are instead passed to the addrmap nodes."),(0,a.yg)("h3",{id:"register-access-methods"},"Register access methods"),(0,a.yg)("p",null,"The 2 mixins will provide at least the ",(0,a.yg)("inlineCode",{parentName:"p"},"get()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"set()")," methods for accessing the register."),(0,a.yg)("h2",{id:"regnode-1"},(0,a.yg)("inlineCode",{parentName:"h2"},"RegNode")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"RegNode")," is a template class inheriting the parameter pack of mixins. The prototype is as shown:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename... RegMixins>\nclass RegNode : public RegMixins...\n")),(0,a.yg)("p",null,"In order to provide Register that have ",(0,a.yg)("inlineCode",{parentName:"p"},"Read"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"Write")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"ReadWrite")," capabilities, the template ",(0,a.yg)("inlineCode",{parentName:"p"},"RegNode")," is inheriting parameter pack of ",(0,a.yg)("inlineCode",{parentName:"p"},"Mixins")," meant to provide the additional functionality."),(0,a.yg)("p",null,"For example:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"RegNode")," inheriting only ",(0,a.yg)("inlineCode",{parentName:"li"},"RegRdMixin")," will be a ",(0,a.yg)("inlineCode",{parentName:"li"},"read-only")," register."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"RegNode")," inheriting only ",(0,a.yg)("inlineCode",{parentName:"li"},"RegWrMixin")," will be a ",(0,a.yg)("inlineCode",{parentName:"li"},"write-only")," register."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"RegNode")," inheriting both ",(0,a.yg)("inlineCode",{parentName:"li"},"RegWrMixin")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"RegRdMixin")," will be a ",(0,a.yg)("inlineCode",{parentName:"li"},"read-write")," register.")),(0,a.yg)("p",null,"In order to ease the use of these templates, common specializations of ",(0,a.yg)("inlineCode",{parentName:"p"},"RegNode")," is already provided under the names:"),(0,a.yg)("h3",{id:"regro"},(0,a.yg)("inlineCode",{parentName:"h3"},"RegRO")),(0,a.yg)("p",null,"is a ",(0,a.yg)("inlineCode",{parentName:"p"},"read-only")," field with a declaration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <uint32_t BASE, uint32_t WIDTH, typename PARENT_TYPE>\nusing RegRO = ...\n")),(0,a.yg)("h3",{id:"fieldwo"},(0,a.yg)("inlineCode",{parentName:"h3"},"FieldWO")),(0,a.yg)("p",null,"is a ",(0,a.yg)("inlineCode",{parentName:"p"},"write-only")," field with a declaration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <uint32_t BASE, uint32_t WIDTH, typename PARENT_TYPE>\nusing RegWO = ...\n")),(0,a.yg)("h3",{id:"fieldrw"},(0,a.yg)("inlineCode",{parentName:"h3"},"FieldRW")),(0,a.yg)("p",null,"is a ",(0,a.yg)("inlineCode",{parentName:"p"},"read-write")," field with a declaration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <uint32_t BASE, uint32_t WIDTH, typename PARENT_TYPE>\nusing RegRW = ...\n")),(0,a.yg)("p",null,"It is advised to use these specializations to construct your registers"))}c.isMDXComponent=!0}}]);